---
title: oc基础知识
date: 2019-01-05 22:06:55
updated: 2019-01-05 22:06:55
tags:
- 移动开发
categories:
- ios
---

# 简介
~~~
Objective-Objective-C是C语言的严格超集；
任何C语言程序不经修改就可以直接通过Objective-C编译器；
在Objective-C中使用C语言代码也是完全合法的；
Objective-C被描述为盖在C语言上的薄薄一层，因为Objective-C的原意就是在C语言主体上加入面向对象的特性；
~~~

# Objective-C代码的文件扩展名
~~~
.h	头文件。头文件包含类，类型，函数和常数的声明。
.m	源代码文件。这是典型的源代码文件扩展名，可以包含 Objective-C 和 C 代码。
.mm	源代码文件。带有这种扩展名的源代码文件，
除了可以包含Objective-C和C代码以外还可以包含C++代码。
仅在你的Objective-C代码中确实需要使用C++类或者特性的时候才用这种扩展名。

当你需要在源代码中包含头文件的时候，你可以使用标准的 #include 编译选项，
但是 Objective-C 提供了更好的方法。#import 选项和 #include 选项完全相同，
只是它可以确保相同的文件只会被包含一次。
Objective-C 的例子和文档都倾向于使用 #import，你的代码也应该是这样的。
~~~

# 语法
~~~
: 继承
() 分类
<> 代理

Objective-C的面向对象语法源于Smalltalk消息传递风格。
所有其他非面向对象的语法，包括变量类型，预处理器（preprocessing），流程控制，函数声明与调用皆与C语言完全一致。
但有些C语言语法合法代码在objective-c中表达的意思不一定相同，比如某些布尔表达式，
在C语言中返回值为true，但在Objective-C若与yes直接相比较，函数将会出错，因为在Objective-C中yes的值只表示为1。
~~~

# 消息传递
~~~
Objective-C最大的特色是承自Smalltalk的消息传递模型（message passing），此机制与今日C++式之主流风格差异甚大。
Objective-C里，与其说对象互相调用方法，不如说对象之间互相传递消息更为精确。
此二种风格的主要差异在于调用方法/消息传递这个动作。
C++里类别与方法的关系严格清楚，一个方法必定属于一个类别，而且在编译时（compile time）就已经紧密绑定，
不可能调用一个不存在类别里的方法。但在Objective-C，类别与消息的关系比较松散，
调用方法视为对对象发送消息，所有方法都被视为对消息的回应。所有消息处理直到运行时（runtime）才会动态决定，
并交由类别自行决定如何处理收到的消息。也就是说，一个类别不保证一定会回应收到的消息，
如果类别收到了一个无法处理的消息，程序只会抛出异常，不会出错或崩溃。

C++里，送一个消息给对象（或者说调用一个方法）的语法如下：
obj.method(argument);
Objective-C则写成：
[obj method: argument];
此二者并不仅仅是语法上的差异，还有基本行为上的不同。
这里以一个汽车类（car class）的简单例子来解释Objective-C的消息传递特性：
[car fly];
典型的C++意义解读是"调用car类别的fly方法"。若car类别里头没有定义fly方法，那编译肯定不会通过。
但是Objective-C里，我们应当解读为"发提交一个fly的消息给car对象"，fly是消息，而car是消息的接收者。
car收到消息后会决定如何回应这个消息，若car类别内定义有fly方法就运行方法内之代码，若car内不存在fly方法，
则程序依旧可以通过编译，运行期则抛出异常。

此二种风格各有优劣。C++强制要求所有的方法都必须有对应的动作，且编译期绑定使得函数调用非常快速。
缺点是仅能借由virtual关键字提供有限的动态绑定能力。
Objective-C天生即具备鸭子类型之动态绑定能力，因为运行期才处理消息，允许发送未知消息给对象。
可以送消息给整个对象集合而不需要一一检查每个对象的类型，也具备消息转送机制。
同时空对象nil接受消息后默认为不做事，所以送消息给nil也不用担心程序崩溃。
~~~

# 类
~~~
// + 代表类方法， - 代表实例方法
class_declare:
"@interface" classNmae(categoryName) ":" subClassName <"protocolname">
"{"
    (["@"("public"|"protected"|"private")] type[\s]+id";")*  // default protected
"}"
("+"|"-") "(" type ")" methodName [":" ( "(" type ")" id )*] ";"
"@end"

class_ Implementation:
"@ implementation" classNmae ":" subClassName
"{"
    (["@"("public"|"protected"|"private")] type[\s]+id";")*  // default private
"}"
("+"|"-") "(" type ")" methodName [":" ( "(" type ")" id )* ] "{" (statement)* "}" 
"@end"
~~~

# 属性
~~~
属性是用来代替声明存取方法的便捷方式。属性不会在你的类声明中创建一个新的实例变量。
他们仅仅是定义方法访问已有的实例变量的速记方式而已。暴露实例变量的类，可以使用属性记号代替getter和setter语法。
类还可以使用属性暴露一些“虚拟”的实例变量，他们是部分数据动态计算的结果，而不是确实保存在实例变量内的。
实际上可以说，属性节约了你必须要写的大量多余的代码。因为大多数存取方法都是用类似的方式实现的，
属性避免了为类暴露的每个实例变量提供不同的getter和setter的需求。
取而代之的是，你用属性声明指定你希望的行为，然后在编译期间合成基于声明的实际的getter和setter方法。
属性声明应该放在类接口的方法声明那里。基本的定义使用@property编译选项，紧跟着类型信息和属性的名字。
你还可以用定制选项对属性进行配置，这决定了存取方法的行为。

属性的访问方法由@synthesize关键字来实现，它由属性的声明自动的产生一对访问方法。
另外，也可以选择使用@dynamic关键字表明访问方法会由程序员手工提供。
~~~

# 类别
~~~
一个分类可以将方法的实现分解进一系列分离的文件。程序员可以将一组相关的方法放进一个分类，使程序更具可读性。
举例来讲，可以在字符串类中增加一个名为"拼写检查"的分类，并将拼写检查的相关代码放进这个分类中。
进一步的，分类中的方法是在运行时被加入类中的，这一特性允许程序员向现存的类中增加方法，而无需持有原有的代码，或是重新编译原有的类。
例如若系统提供的字符串类的实现中不包含拼写检查的功能，可以增加这样的功能而无需更改原有的字符串类的代码。
在运行时，分类中的方法与类原有的方法并无区别，其代码可以访问包括私有类成员变量在内的所有成员变量。
若分类声明了与类中原有方法同名的函数，则分类中的方法会被调用。因此分类不仅可以增加类的方法，也可以代替原有的方法。
这个特性可以用于修正原有代码中的错误，更可以从根本上改变程序中原有类的行为。若两个分类中的方法同名，则被调用的方法是不可预测的。
其它语言也尝试了通过不同方法增加这一语言特性。TOM在这方面走的更远，不仅允许增加方法，更允许增加成员变量。
也有其它语言使用面向声明的解决方案，其中最值得注意的是Self语言。
C#与Visual Basic.NET语言以扩展函数的与不完全类的方式实现了类似的功能。
Ruby与一些动态语言则以"monkey patch"的名字称呼这种技术。
~~~

# 垃圾回收
~~~
Objective-C 2.0提供了一个可选的垃圾收集器。在向后兼容模式中，Objective-C运行时会将引用计数操作，例如"retain"与"release"变为无操作。
当垃圾收集启用时，所有的对象都是收集器的工作对象。普通的C指针可以以"__strong"修饰，标记指针指向的对象仍在使用中。
被标记为"__weak"的指针不被计入收集器的计数中，并在对象被回收时改写为"nil"。
iOS上的Objective-C 2.0实现中不包含垃圾收集器。
垃圾收集器运行在一个低优先级的后台线程中，并可以在用户动作时暂停，从而保持良好的用户体验
~~~

# Arc mrc 内存管理
~~~
Objective-c中提供了两种内存管理机制MRC（MannulReference Counting）和ARC(Automatic Reference Counting)，
分别提供对内存的手动和自动管理，来满足不同的需求。其实arc 内部机制原理也是来源于mrc ，
arc 是在 iOS 5/ Mac OS X 10.7 开始导入，利用 Xcode4.2 可以使用该机能。
arc的首要目的就是让代码简洁化，编程简单化，开发更顺心应手，减少不必要的小问题小疏忽；
顾名思义，自动引用计数管理，关于内存的申请，使用和释放过程都交给系统自动实现，
我们可也不用关系里面的过程，但是事实上还是mrc的原理，只是是系统帮我们做了管理；
mrc，手动引用计数器管理，是在我们申请到某一块内存，在使用之后，要手动释放，释放机理涉及到计数器问题，
如果未释放内存，会造成内存的浪费，俗称内存泄露，甚至引起很多未知的错误结果，
这对程序有威胁很大，但是，何时释放，怎么释放，注意哪些问题，很有讲究，这就是mrc的不便之处，也是苹果推出arc的缘由；
mrc的具体机理，计数器是什么，在程序过程中的变化，在达到什么程度会释放内存，怎么操作；建议查阅相关文档；
mrc ，在代码上下形式主要表现为，调用该对象时，要做retain操作，使用完成后要release，
最后还要重写dealloc方法，对该类的所有对象做释放，所以在mrc的代码会有autorelease，retain，release等词语，
而arc不允许有这些词汇，应为这些操作都由系统自动完成。
引用计数器
1.和内存管理相关的方法
1）alloc 引用计数器自动设为1
2）retain 引用计数器+1 返回了经过+1以后的当前实例对象
3）release 引用计数器-1，并不一定是释放
4）retainCount 获取引用计数器的值
5）dealloc 当实例对象被销毁之前，系统自动调用。
一定要调[super dealloc]
和内存管理相关的名词
1）僵尸对象：此对象被销毁，不能再使用，不能给它发送任何消息
2）野指针：指向僵尸对象（不可用的内存）的指针，给野指针发送消息将会产生不可控的后果。
3）空指针：没有指向任何对象的指针，给空指针发消息不会产生任何行为
内存管理原则
1.如果你想持有某个对象，就必须负责让做一次retain操作，引用计数器+1.
2.如果你想放弃对某个对象的持有权，就要负责让其做一次release操作，引用计数器-1.
3.谁retain，谁release。
~~~

# block 匿名函数
[block讲解](http://www.jianshu.com/p/3f8040766a7f)

# KVC 与 KVO
[KVC /KVO的底层原理和使用场景](https://www.jianshu.com/p/2ea8bd7a372b)
[详解](https://www.jianshu.com/p/b9f020a8b4c9)

# 布局
[1](http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/)
[2](http://www.cocoachina.com/ios/20141219/10702.html)
[3](http://www.cocoachina.com/ios/20151029/13872.html)
[Masonry](https://github.com/SnapKit/Masonry )

# Property synthesize
[](http://www.cnblogs.com/decomfor/p/5324128.html)

# 
~~~
__weak 和 __strong 会出现在声明中

默认情况下，一个指针都会使用 __strong 属性，表明这是一个强引用。这意味着，只要引用存在，对象就不能被销毁。
这是一种所期望的行为：当所有（强）引用都去除时，对象才能被收集和释放。
不过， 有时我们却希望禁用这种行为：一些集合类不应该增加其元素的引用，因为这会引起对象无法释放。
在这种情况下，我们需要使用弱引用（不用担心，内置的集合类 就是这么干的），使用 __weak 关键字。
NSHashTable 就是一个例子。当被引用的对象消失时，弱引用会自动设置为 nil。

自己更深理解：
1.(weak与strong)不同的是：当一个对象不再有strong类型的指针指向它的时候，它就会被释放，
即使改对象还有_weak类型的指针指向它；
2.一旦最后一个指向该对象的strong类型的指针离开，这个对象将被释放，如果这个时候还有weak指针指向该对象，
则会清除掉所有剩余的weak指针
类比为自己的思想：
  一个对象类比为一条狗,释放对象类比为狗要跑掉
逻辑：
	strong类型的指针就像是栓住的狗，只要你用绳子拴住狗，那么狗就不会跑掉.
	类比一个对象new过以后，不会自动的释放
	如果有5个人都牵着这一条狗(5条绳子栓一只狗)类比为5个strong类型指针指向一个对象.
	除非5个绳子都脱落，否则狗是不会跑掉的，类比5个strong指针都=nil，则该对象释放

weak型指针就像是一个小孩子指着狗喊道：“看，有一只狗在那里”，只要狗一直被拴着，
那么小孩子就能看到狗 （weak指针）会一直指向它， 只要狗的绳子脱落，那么狗就会跑掉，
不管有多少的小孩在看着它。 只要最后一个strong型指针不再指向对象，那么对象就会被释放，
同时所有的weak型指针都将会被清除。

在OC中strong就相当于retain属性，而weak相当于assign。
只有一种情况你需要使用weak（默认是strong），就是为了避免retain cycles（就是父类中含有子类{父类retain了子类}，
子类中又调用了父类{子类又retain了父类}，这样都无法release）
~~~

[转载自](http://blog.sina.com.cn/s/blog_7c8dc2d50101lc08.html)
